<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Checklist de Atividades</title>
  <style>
    :root{ --bg:#f4f7fb; --card:#ffffff; --accent:#6ea8fe; --muted:#6b7280; --danger:#ff6b6b; --radius:12px; --priority-bg:#eef8ff; }
    *{box-sizing:border-box;font-family:Inter, "Segoe UI", Roboto, Arial, sans-serif}
    body{ margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,var(--bg),#eef4ff 120%); padding:24px; color:#0f172a; }
    .container{ width:100%; max-width:900px; background:var(--card); border-radius:var(--radius); box-shadow:0 10px 30px rgba(15,23,42,0.08); padding:26px; }
    h1{ margin:0 0 6px 0; font-size:20px; color:#08306b; }
    p.lead{ margin:0 0 14px 0; color:var(--muted); font-size:14px; }
    .input-area{ display:flex; gap:8px; margin-bottom:14px; align-items:center; }
    input[type="text"]{ flex:1; padding:12px 14px; border:1px solid #e6eefc; border-radius:10px; background:#fbfdff; font-size:15px; outline:none; transition:box-shadow .12s, border-color .12s; }
    input[type="text"]:focus{ box-shadow:0 4px 14px rgba(110,168,254,0.14); border-color:var(--accent); }
    select.priority-select{ padding:10px; border-radius:10px; border:1px solid #e6eefc; background:#fff; font-size:14px; color:#082145; }
    button{ border:0; cursor:pointer; padding:10px 14px; border-radius:10px; font-weight:600; color:white; background:linear-gradient(180deg,var(--accent),#4b8bfc); box-shadow:0 6px 14px rgba(75,139,252,0.16); }
    button:active{transform:translateY(1px)}
    button.ghost{ background:transparent; color:var(--accent); box-shadow:none; border:1px solid rgba(75,139,252,0.12); }
    ul#taskList{ list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:10px; margin-top:8px; }
    .task-item{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 12px; border-radius:10px; background:linear-gradient(180deg,#fff,#fbfdff); border:1px solid #f1f7ff; transition:transform .08s, box-shadow .08s; user-select:none; }
    .task-item:hover{transform:translateY(-2px); box-shadow:0 8px 20px rgba(15,23,42,0.04)}
    .task-left{ display:flex; align-items:center; gap:12px; flex:1; min-width:0; }
    .drag-handle{ font-size:18px; padding:6px; border-radius:8px; color:#6b7280; cursor:grab; display:inline-flex; align-items:center; justify-content:center; }
    .drag-handle:active{cursor:grabbing}
    .task-item.dragging{opacity:0.6; transform:scale(0.995)}
    .task-text{ font-size:15px; color:#082145; word-break:break-word; }
    .task-text.completed{ text-decoration:line-through; color:var(--muted); opacity:0.85; }
    .priority-badge{ background:var(--priority-bg); color:#0b3b6f; padding:6px 8px; border-radius:8px; font-size:13px; font-weight:700; min-width:36px; text-align:center; }
    .task-meta{ display:flex; align-items:center; gap:10px; }
    .delete-btn{ background:transparent; padding:8px; border-radius:8px; color:var(--danger); font-size:18px; line-height:1; box-shadow:none; }
    .delete-btn:hover{ background:rgba(255,107,107,0.06); }
    .actions{ display:flex; justify-content:flex-end; margin-top:16px; gap:8px; }
    .small{ font-size:13px; color:var(--muted); }
    @media (max-width:640px){ .input-area{flex-direction:column; align-items:stretch} .actions{justify-content:center} .task-meta{gap:6px} }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Checklist de Atividades">
    <h1>Checklist de Atividades</h1>
    <p class="lead">Arraste para priorizar, adicione, marque, faça upload e baixe sua lista como .txt</p>

    <div class="input-area" aria-hidden="false">
      <input id="taskInput" type="text" placeholder="Digite uma nova tarefa..." aria-label="Nova tarefa" />
      <select id="priorityInput" class="priority-select" aria-label="Prioridade inicial">
        <option value="auto">Prioridade automática</option>
        <option value="high">Alta</option>
        <option value="medium">Média</option>
        <option value="low">Baixa</option>
      </select>
      <button id="addBtn" aria-label="Adicionar tarefa">Adicionar</button>
    </div>

    <ul id="taskList" aria-live="polite"></ul>

    <div class="actions">
      <button id="saveBtn" title="Salvar e baixar arquivo .txt">💾 Salvar / Baixar</button>
      <button id="uploadBtn" class="ghost" title="Carregar arquivo .txt de tarefas">📤 Upload</button>
      <button id="clearAllBtn" class="ghost" title="Remover todas as tarefas">Limpar tudo</button>
    </div>

    <p class="small" style="margin-top:12px">Dica: pressione Enter para adicionar. Arraste a alça (≡) para alterar a ordem. Ao fazer upload, você pode escolher adicionar ou substituir as tarefas atuais.</p>
  </div>

  <!-- input[type=file] oculto para o Upload -->
  <input id="fileInput" type="file" accept=".txt,text/plain" style="display:none" />

  <script>
    // Elementos principais
    const taskInput = document.getElementById('taskInput');
    const priorityInput = document.getElementById('priorityInput');
    const addBtn = document.getElementById('addBtn');
    const taskList = document.getElementById('taskList');
    const saveBtn = document.getElementById('saveBtn');
    const uploadBtn = document.getElementById('uploadBtn');
    const clearAllBtn = document.getElementById('clearAllBtn');
    const fileInput = document.getElementById('fileInput');

    let draggedEl = null;

    // createTaskElement: cria o DOM de cada tarefa, com checkbox, alça de arraste, seletor de prioridade e botão de excluir.
    function createTaskElement(text, completed = false, preferredPriority = 'auto') {
      const li = document.createElement('li');
      li.className = 'task-item';
      li.draggable = true; // torna arrastável
      li.setAttribute('aria-grabbed','false');

      // esquerda: alça + checkbox + texto
      const left = document.createElement('div');
      left.className = 'task-left';

      const dragHandle = document.createElement('div');
      dragHandle.className = 'drag-handle';
      dragHandle.innerText = '≡';
      dragHandle.title = 'Arraste para reordenar';
      dragHandle.setAttribute('aria-hidden','true');

      const label = document.createElement('label');
      label.style.display = 'flex';
      label.style.alignItems = 'center';
      label.style.gap = '10px';
      label.style.cursor = 'pointer';
      label.style.flex = '1';
      label.style.minWidth = '0';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.className = 'task-checkbox';
      checkbox.checked = completed;
      checkbox.setAttribute('aria-label', 'Marcar tarefa como concluída');

      const span = document.createElement('span');
      span.className = 'task-text';
      span.textContent = text;
      if (completed) span.classList.add('completed');

      // marca/desmarca riscando o texto
      checkbox.addEventListener('change', () => {
        span.classList.toggle('completed', checkbox.checked);
      });

      label.appendChild(checkbox);
      label.appendChild(span);
      left.appendChild(dragHandle);
      left.appendChild(label);

      // direita: badge de prioridade, seletor pequeno e botão excluir
      const meta = document.createElement('div');
      meta.className = 'task-meta';

      const badge = document.createElement('div');
      badge.className = 'priority-badge';
      badge.textContent = ''; // preenchido por updatePriorities ou pelo seletor

      const smallSelect = document.createElement('select');
      smallSelect.className = 'priority-select';
      smallSelect.style.padding = '6px';
      smallSelect.style.fontSize = '13px';
      smallSelect.innerHTML = `
        <option value="auto">Auto</option>
        <option value="high">Alta</option>
        <option value="medium">Média</option>
        <option value="low">Baixa</option>
      `;
      smallSelect.value = preferredPriority || 'auto';
      smallSelect.addEventListener('change', () => {
        applyPriorityVisual(badge, smallSelect.value);
        updatePriorities();
      });
      applyPriorityVisual(badge, smallSelect.value);

      const delBtn = document.createElement('button');
      delBtn.className = 'delete-btn';
      delBtn.title = 'Excluir tarefa';
      delBtn.setAttribute('aria-label', 'Excluir tarefa');
      delBtn.innerText = '🗑️';
      delBtn.addEventListener('click', () => { li.remove(); updatePriorities(); });

      meta.appendChild(badge);
      meta.appendChild(smallSelect);
      meta.appendChild(delBtn);

      li.appendChild(left);
      li.appendChild(meta);

      // Drag & Drop events
      li.addEventListener('dragstart', (e) => {
        draggedEl = li;
        li.classList.add('dragging');
        li.setAttribute('aria-grabbed','true');
        e.dataTransfer.effectAllowed = 'move';
        try { e.dataTransfer.setData('text/plain',''); } catch (err) {}
      });

      li.addEventListener('dragend', () => {
        if (draggedEl) {
          draggedEl.classList.remove('dragging');
          draggedEl.setAttribute('aria-grabbed','false');
          draggedEl = null;
        }
        updatePriorities();
      });

      return li;
    }

    // aplica estilo da badge conforme prioridade manual
    function applyPriorityVisual(badgeEl, priority) {
      badgeEl.style.background = '';
      badgeEl.style.color = '';
      if (priority === 'high') {
        badgeEl.style.background = '#ffecec';
        badgeEl.style.color = '#8a1f1f';
        badgeEl.textContent = 'Alta';
      } else if (priority === 'medium') {
        badgeEl.style.background = '#fff7e6';
        badgeEl.style.color = '#6b4b00';
        badgeEl.textContent = 'Média';
      } else if (priority === 'low') {
        badgeEl.style.background = '#eef8ff';
        badgeEl.style.color = '#0b3b6f';
        badgeEl.textContent = 'Baixa';
      } else {
        badgeEl.style.background = 'var(--priority-bg)';
        badgeEl.style.color = '#0b3b6f';
        badgeEl.textContent = '';
      }
    }

    // adiciona nova tarefa (respeitando prioridade 'high' que insere no topo)
    function addTask() {
      const text = taskInput.value.trim();
      if (!text) { taskInput.focus(); return; }
      const preferred = priorityInput.value || 'auto';
      const taskEl = createTaskElement(text, false, preferred);
      if (preferred === 'high') taskList.insertBefore(taskEl, taskList.firstChild);
      else taskList.appendChild(taskEl);
      taskInput.value = '';
      taskInput.focus();
      updatePriorities();
    }

    // atualiza badges: se seletor estiver em 'auto', mostra a posição (1 = topo)
    function updatePriorities() {
      const items = Array.from(taskList.children);
      items.forEach((li, index) => {
        const badge = li.querySelector('.priority-badge');
        const smallSelect = li.querySelector('.priority-select');
        if (smallSelect && smallSelect.value === 'auto') {
          badge.textContent = String(index + 1);
          badge.style.background = 'var(--priority-bg)';
          badge.style.color = '#0b3b6f';
        } else {
          applyPriorityVisual(badge, smallSelect.value);
        }
      });
    }

    // retorna o elemento depois da posição Y durante dragover para inserir corretamente
    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.task-item:not(.dragging)')];
      let closest = { offset: Number.NEGATIVE_INFINITY, element: null };
      for (const child of draggableElements) {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
          closest = { offset: offset, element: child };
        }
      }
      return closest.element;
    }

    // salva e baixa um .txt com a ordem atual, status e prioridade manual
    function saveAndDownload() {
      const items = Array.from(taskList.querySelectorAll('.task-item'));
      if (items.length === 0) { alert('Não há tarefas para salvar.'); return; }
      const lines = items.map((li, index) => {
        const checkbox = li.querySelector('.task-checkbox');
        const text = li.querySelector('.task-text').textContent.replace(/\r?\n/g, ' ');
        const smallSelect = li.querySelector('.priority-select');
        const priorityLabel = smallSelect && smallSelect.value !== 'auto' ? ` (${smallSelect.value})` : '';
        return `${index + 1}. ${checkbox.checked ? '[X]' : '[ ]'} ${text}${priorityLabel}`;
      });

      const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'minhas_tarefas.txt';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function clearAllTasks() {
      if (!taskList.hasChildNodes()) return;
      if (confirm('Deseja realmente remover todas as tarefas?')) taskList.innerHTML = '';
    }

    // parseTasksFromText: interpreta linhas do .txt exportado, aceita formas como:
    // "1. [X] Fazer algo (medium)" ou "[ ] Outra tarefa" ou com prioridade em pt/en.
    function parseTasksFromText(content) {
      const lines = content.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      const tasks = [];
      for (let raw of lines) {
        let line = raw;
        // remove prefixo numérico "1. "
        line = line.replace(/^\s*\d+\.\s*/, '');

        // detecta prioridade em parênteses no final (aceita pt/en)
        let priority = 'auto';
        const prMatch = line.match(/\((\s*high|high|medium|low|alta|m[eé]dia|media|baixa)\)\s*$/i);
        if (prMatch) {
          const rawPr = prMatch[1].toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
          if (rawPr.includes('high') || rawPr.includes('alta')) priority = 'high';
          else if (rawPr.includes('medium') || rawPr.includes('media') || rawPr.includes('m')) priority = 'medium';
          else if (rawPr.includes('low') || rawPr.includes('baixa')) priority = 'low';
          line = line.replace(/\((?:\s*high|high|medium|low|alta|m[eé]dia|media|baixa)\)\s*$/i, '').trim();
        }

        // detecta status "[X]" ou "[ ]" no começo
        let completed = false;
        const statusMatch = line.match(/^\s*\[(x|X| )\]\s*/);
        if (statusMatch) {
          const mark = statusMatch[1];
          completed = (mark.toLowerCase() === 'x');
          line = line.replace(/^\s*\[(x|X| )\]\s*/, '').trim();
        } else {
          const anyX = line.match(/\[(x|X)\]/);
          if (anyX) { completed = true; line = line.replace(/\[(x|X)\]/, '').trim(); }
        }

        if (line.length > 0) tasks.push({ text: line, completed, priority });
      }
      return tasks;
    }

    // lê arquivo .txt e importa tarefas; pergunta se adicionar ou substituir
    function handleFileUpload(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target.result;
        const tasks = parseTasksFromText(text);
        if (tasks.length === 0) { alert('Nenhuma tarefa válida encontrada no arquivo.'); return; }

        if (taskList.hasChildNodes()) {
          const add = confirm('Deseja ADICIONAR as tarefas do arquivo às tarefas atuais? (OK = Adicionar / Cancel = Substituir)');
          if (!add) taskList.innerHTML = '';
        }

        for (const t of tasks) {
          const el = createTaskElement(t.text, t.completed, t.priority);
          taskList.appendChild(el);
        }
        updatePriorities();
        alert(`Foram importadas ${tasks.length} tarefas.`);
      };
      reader.onerror = () => { alert('Erro ao ler o arquivo. Verifique o arquivo e tente novamente.'); };
      reader.readAsText(file, 'UTF-8');
    }

    // --- eventos ---
    addBtn.addEventListener('click', addTask);
    taskInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addTask(); });
    saveBtn.addEventListener('click', saveAndDownload);
    clearAllBtn.addEventListener('click', clearAllTasks);

    uploadBtn.addEventListener('click', () => { fileInput.value = ''; fileInput.click(); });
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      if (!f.type || f.type === '' || f.type.startsWith('text') || f.name.endsWith('.txt')) handleFileUpload(f);
      else if (confirm('Parece que o arquivo não é .txt. Deseja tentar importar mesmo assim?')) handleFileUpload(f);
    });

    // dragover container -> insere draggedEl na posição correta
    taskList.addEventListener('dragover', (e) => {
      e.preventDefault();
      const afterElement = getDragAfterElement(taskList, e.clientY);
      if (draggedEl == null) return;
      if (afterElement == null) taskList.appendChild(draggedEl);
      else taskList.insertBefore(draggedEl, afterElement);
    });

    // Exemplo inicial (pode remover)
    taskList.appendChild(createTaskElement('Exemplo: Comprar leite', false, 'high'));
    taskList.appendChild(createTaskElement('Exemplo: Estudar 30 minutos', true, 'auto'));
    updatePriorities();

    /* Principais funções comentadas:
       - createTaskElement(text, completed, preferredPriority): cria o DOM e liga eventos (checkbox, delete, drag).
       - parseTasksFromText(content): converte o .txt gerado pelo botão salvar em objetos {text, completed, priority}.
       - handleFileUpload(file): lê o arquivo, chama o parser e insere as tarefas (pergunta adicionar/substituir).
       - saveAndDownload(): gera e baixa o arquivo .txt (ordem atual + [X]/[ ] + prioridade opcional).
       - updatePriorities(): atualiza badges para mostrar a posição ou prioridade manual.
    */
  </script>
</body>
</html>